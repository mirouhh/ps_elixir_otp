# Elixir & OTP #
## Learning a functional language may seem daunting, but what if it was delightful instead? ##
**Elixir is a fantastic functional language that's practical, enjoyable, and easy on the eyes.** ü§©

But it's more than just syntax sparkle and cool language features.

**What sets Elixir apart is that it runs on the BEAM (the Erlang VM).**

And the BEAM totally rocks.

It was designed specifically for creating scalable, fault-tolerant systems. Spinning up a million supervised processes is just table stakes for the BEAM. After decades of production use, it's still the undisputed king of reliability. üëë

**And then there's OTP.**

It's a set of battle-tested abstractions for building highly concurrent, distributed applications. GenServers and Supervisors are the two main workhorses. The OTP libraries give you a huge amount of leverage.

Elixir + OTP + BEAM = üíú

**Indeed, Elixir is uniquely positioned for building today's demanding systems.**

It's a versatile language with many real-world uses:

‚úÖ real-time, interactive web applications with Phoenix</br>
‚úÖ machine learning and concurrent data processing systems</br>
‚úÖ high-volume request and messaging apps</br>
‚úÖ and even fleets of IoT devices managed by Nerves

Aside from that, adding Elixir to your repertoire will make you a more well-rounded (and employable!) developer. ü§ì

Sounds pretty great, right?

**And it's tempting to jump straight into Elixir and hope for the best.**

But that's like being airdropped into a foreign city without a map or translator.

Haphazardly trying to "feel" your way around a new language is disorienting and frustrating. You don't know where things are or how things are connected. So you bounce from one topic to the next hoping to fill everything in. But you just end up with <ins>knowledge gaps that become pitfalls</ins> when you try to build something real with Elixir.

At the worst, you simply give up.

At the best, you copy-paste code without knowing how or why it works. ü•≤

**Imagine writing Elixir as effortlessly as any other language in your toolkit.**

Everything would finally click:

‚≠êÔ∏è You'd know all the idioms and best practices.</br>
‚≠êÔ∏è You'd confidently design code in the spirit of Elixir.</br>
‚≠êÔ∏è You'd wield all the power of OTP.</br>
‚≠êÔ∏è Writing Elixir would be fun, not frustrating.

**This comprehensive course has everything you need, in the right order, and in one place!** üëç

No need to scour the web and waste your time piecing together resources. We distilled everything you need to know about Elixir and OTP into an approachable and ‚Äîdare we say‚Äî pragmatic video course.

Our course has worked for <ins>thousands of developers</ins> because it builds an application step by step in a clear, logical progression.

It starts with Elixir fundamentals and gently builds up to the OTP abstractions so you know when and why to use them. And yeah, there are a few bad puns along the way, but we do try to make it fun. ü§™
 







36 Videos ‚Ä¢ 6 Hours
We build an app feature-by-feature in the videos so you see and understand exactly how it's done. Each live-coding video is:

tightly-edited to respect your time
straight to the point without any rambling or fumbling
perfectly paced so you're not left behind or nodding off
streamable with English subtitles and also downloadable










Blocks are an intrinsic and powerful aspect of the language. Many of the methods in the Ruby standard library assume you have a solid understanding of blocks. And blocks are used pervasively in Ruby gems (including Ruby on Rails) and all well-designed Ruby code.

In this hands-on video course, you'll learn blocks and iterators by example with over 40 real-world examples!
Blocks are an intrinsic and powerful aspect of the language. Many of the methods in the Ruby standard library assume you have a solid understanding of blocks. And blocks are used pervasively in Ruby gems (including Ruby on Rails) and all well-designed Ruby code.

In this hands-on video course, you'll learn blocks and iterators by example with over 40 real-world examples!

## Learn By Example and Exercise ##
#### Explore blocks used in 40+ real-world examples. ####
### Block Basics ###
To be an effective Ruby programmer, you need to be very proficient with blocks. We'll start with the basics and work up to advanced block usage. In the end you'll be able to read and write any code that uses blocks.

### When, Why, and How to Use Blocks ###
Once you're comfortable with the syntax, the next level is to understand when and why to use blocks. And the best way to do that is by looking at lots of good examples. You'll learn how to effectively apply blocks in a variety of situations to make your code more expressive, concise, and flexible.

### Master the Enumerable Module ###
The methods in the Enumerable module‚Äîselect, reject, map, reduce, and friends‚Äîare particularly great examples of the power of blocks. And once you grasp blocks, the secret to all these methods is suddenly revealed. Master the Enumerable methods and you'll be a more efficient Ruby programmer!

### Custom Iterators ###
Ruby's built-in iterator methods‚Äîeach, times, and so on‚Äî aren't "magical" once you understand how to yield to a block. Learn how to design your own classes and APIs using custom iterators like the ones you use every day.

### Design Techniques & Patterns ###
Blocks offer a different (powerful!) style of programming that should influence the design of your code. Throughout the course we'll examine many use cases where blocks elegantly solve common problems. Discover how to use blocks to remove unnecessary code, manage resources, and more! You'll be able to immediately apply these techniques and patterns to your own code.

### Real-World, Practical Examples ###
No dry definitions or boring theory here. This course is loaded with good examples of blocks and iterators used in various scenarios. By seeing recurring patterns in different contexts, you'll come away with a clear understanding of not just how blocks work but, equally important, when and where to use them.

## Full Course Outline ##
1. [Introduction and Setup](https://github.com/mirouhh/ps_ruby_blocks/tree/main/01_Introduction_and_Setup)
2. [Block Basics](https://github.com/mirouhh/ps_ruby_blocks/tree/main/02_Block_Basics)
3. [Each](https://github.com/mirouhh/ps_ruby_blocks/tree/main/03_Each)
4. [Enumerable (Pt.1)](https://github.com/mirouhh/ps_ruby_blocks/tree/main/04_Enumerable) and [Enumerable (Pt.2)](https://github.com/mirouhh/ps_ruby_blocks/tree/main/04_Enumerable_Pt_2)
5. [Yielding](https://github.com/mirouhh/ps_ruby_blocks/tree/main/05_Yielding)
6. [Custom Iterators](https://github.com/mirouhh/ps_ruby_blocks/tree/main/06_Custom_Iterators) and [Custom Iterators : Bonus](https://github.com/mirouhh/ps_ruby_blocks/tree/main/06_Custom_Iterators_Bonus)
7. [Use Cases: Execute Around](https://github.com/mirouhh/ps_ruby_blocks/tree/main/07_Use_Cases_Execute_Around)
8. [Use Cases: Toggle Around](https://github.com/mirouhh/ps_ruby_blocks/tree/main/08_Use_Cases_Toggle_Around)
9. [Use Cases: Block Initializer](https://github.com/mirouhh/ps_ruby_blocks/tree/main/09_Use_Cases_Block_Initializer)
10. [Use Cases: Manage Resources](https://github.com/mirouhh/ps_ruby_blocks/tree/main/10_Use_Cases_Manage_Resources)

This repository is containing the source code for the examples and the exercises of this course only. If you want to know more about this course please visit the [website](https://pragmaticstudio.com/ruby-blocks) of this course by [The Pragmatic Studio](https://pragmaticstudio.com/).